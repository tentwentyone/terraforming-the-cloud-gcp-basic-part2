{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "terraforming-the-cloud-gcp-2",
  "steps": [
    {
      "file": "tutorial.md",
      "description": "Bem-vindo Ã  segunda parte do nosso workshop!\n\nAqui tens um breve resumo dos conteÃºdos abordados neste mÃ³dulo.\n\nAproveita para dar uma vista de olhos nos tÃ³picos e verificar se tens todos os requisitos para prosseguir com o workshop.",
      "line": 2
    },
    {
      "file": "tutorial.md",
      "description": "Certifica-te que estÃ¡s no teu terminal fazendo o comando:\n- **ctrl+Ã§**\n\nAlternativamente, no canto superior esquerdo, podes tambÃ©m clicar em:\n\n- **View** e depois selecionar **Terminal**",
      "line": 3
    },
    {
      "file": "tutorial.md",
      "description": "No terminal faz login em GCP utilizando o comando:\n>> gcloud auth login --update-adc --no-launch-browser",
      "line": 4
    },
    {
      "file": "tutorial.md",
      "description": "Para definir o projecto faz o comando:\n>> gcloud config set project ten21-wshop01-p-154457 && gcloud config set accessibility/screen_reader false\n\nCertifica-te que estÃ¡s no projecto correcto fazendo o comando:\n>> gcloud config get-value project\n\n\nSe quiseres ver todos os projectos a que tens acesso faz o comando:\n>> gcloud projects list",
      "line": 5
    },
    {
      "file": "terraform.tfvars",
      "selection": {
        "start": {
          "line": 2,
          "character": 1
        },
        "end": {
          "line": 3,
          "character": 30
        }
      },
      "description": "## 0. terraform init\n\nPara evitar que o terraform peÃ§a o nome do projeto a cada apply, podemos definir o nome do projeto por defeito:\n\n- Descomenta a linha **project_id** e adiciona o **id do projecto.**\n\nNeste projeto temos que preparar um prefixo que identifique unicamente os recursos que vÃ£o ser criados, por forma a evitar colisÃµes.\n\n- Define um prefixo **user_prefix = \"valor\"**\n\nPara descomentar seleciona o bloco e faz o comando:\n\n- Windows: **CTRL + K + U**\n- Mac: **CMD + K + U**"
    },
    {
      "file": "variables.tf",
      "selection": {
        "start": {
          "line": 31,
          "character": 1
        },
        "end": {
          "line": 39,
          "character": 2
        }
      },
      "description": "ğŸ’¡Notem que a variavel **user_prefix** tem uma validaÃ§Ã£o declarada no ficheiro *variables.tf*. Caso estejam a ter um erro, Ã© preciso garantir queo nome escolhido cumpre com as regras de validaÃ§Ã£o.\n\nInicializar:\n\n>> terraform init"
    },
    {
      "file": "main.tf",
      "description": "Planear:\n\n>> terraform plan -out plan.tfplan\n\nAplicar:\n\n>> terraform apply plan.tfplan",
      "line": 28
    },
    {
      "file": "vpc.tf",
      "selection": {
        "start": {
          "line": 4,
          "character": 1
        },
        "end": {
          "line": 51,
          "character": 4
        }
      },
      "description": "## 1. Criar VPC e Subnet\n\nNo ficheiro vpc.tf encontram-se as definiÃ§Ãµes da VPC e respetiva subnet a usar\n\nğŸ‘‰ Descomentar as seguintes resources:\n\n*resource \"google_compute_network\" \"default\"*\n\n*resource \"google_compute_subnetwork\" \"gke\"*\n\n*resource \"google_compute_router\" \"default\"*\n\n*resource \"google_compute_router_nat\" \"default\"*\n\nPara descomentar seleciona o bloco e faz o comando:\n\n- Windows: **CTRL + K + U**\n- Mac: **CMD + K + U**\n\nğŸ’¡**Why**: Tanto o router como o nat sÃ£o recursos necessÃ¡rios para permitir que o cluster GKE possa aceder Ã  internet para fazer download das imagens dos containers que vamos usar."
    },
    {
      "file": "vpc.tf",
      "description": "Executar o plan\n\n>> terraform plan -out plan.tfplan\n\nExecutar o apply:\n\n>> terraform apply plan.tfplan\n\nValidar the a VPC foi criada:\n\n>> gcloud compute networks list | grep $(terraform output -raw my_identifier)\n\nValidar que a subnet foi criada:\n\n>> gcloud compute networks subnets list | grep \"$(terraform output -raw my_identifier)\"",
      "line": 52
    },
    {
      "file": "modules/gke/gke.tf",
      "description": "## 2. Modules & GKE\n\nNeste capitulo iremos abordar a utilizaÃ§Ã£o de terraform modules para instanciar o GKE.\n\n### 2.1 IntroduÃ§Ã£o aos modulos\nExemplo demonstrativo da organizaÃ§Ã£o de modulos no slide 12 da apresentaÃ§Ã£o.\n\nfrom docs: A module is a container for multiple resources that are used together.\n\nEvery Terraform configuration has at least one module, known as its root module, which consists of the resources defined in the .tf files in the main working directory.\n\nA module can call other modules, which lets you include the child module's resources into the configuration in a concise way. Modules can also be called multiple times, either within the same configuration or in separate configurations, allowing resource configurations to be packaged and re-used.",
      "line": 1
    },
    {
      "file": "gke.tf",
      "selection": {
        "start": {
          "line": 2,
          "character": 1
        },
        "end": {
          "line": 16,
          "character": 4
        }
      },
      "description": "## 2.2 GKE module\n\nAgora que temos os pre-requisitos instalados, iremos entao proceder Ã  primeira aplicaÃ§Ã£o de um [terraform module](https://www.terraform.io/docs/language/modules/syntax.html) para aprovisionar um cluster GKE.\n\nNo ficheiro **./gke.tf** encontra-se a invocaÃ§Ã£o do module\n\nPor cada module Ã© preciso fazer **terraform init**\n\nğŸ‘‰ No ficheiro **./gke.tf**, descomentar as seguintes resources:\n\n*module \"gke\"*\n\n*output \"gke_name\"*\n\n*output \"gke_location\"*"
    },
    {
      "file": "gke.tf",
      "description": "Primeiro temos que executar **terraform init** para inicializar o modulo:\n\n>> terraform init\n\nExecutar o plan:\n\n>> terraform plan -out plan.tfplan\n\nExecutar o apply:\n\n>> terraform apply plan.tfplan\n\nâ° Notem que a criaÃ§Ã£o de um cluster GKE pode levar atÃ© 10 minutos...\n\nPodemos verificar que o nosso cluster foi corretamente criado atravÃ©s do comando:\n\n>> gcloud container clusters list --project $(terraform output -raw project_id) | grep $(terraform output -raw my_identifier)",
      "line": 15
    },
    {
      "file": "gke.tf",
      "description": "## 2.3 Aceder ao cluster\n\nO acesso a um GKE, tal como qualquer outro cluster de Kubernetes, Ã© feito a partir da cli kubectl. Para podermos executar comandos kubectl precisamos primeiro de garantir que temos uma configuraÃ§Ã£o vÃ¡lida para aceder ao nosso cluster.\n\nUsar o comando gcloud para construir um KUBECONFIG vÃ¡lido para aceder ao cluster:\n\n>> export KUBECONFIG=$(pwd)/kubeconfig.yaml && gcloud container clusters get-credentials $(terraform output -raw gke_name) --zone $(terraform output -raw gke_location) --project $(terraform output -raw project_id)\n\nVerificar o acesso ao cluster:\n\n>> kubectl get nodes",
      "line": 16
    },
    {
      "file": "k8s.hipster.tf",
      "description": "## 2.4. Vamos por workloads a correr\n\nNesta secÃ§Ã£o abordar a utilizaÃ§Ã£o de um provider ([kubectl provider](https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs)) para instanciar (via terraform) todos os workloads que vÃ£o correr no nosso cluster.\n\nTrata-se de um provider da comunidade que tal como o nome indica, facilita a utilizaÃ§Ã£o de terraform para orquestrar ficheiros yaml.",
      "line": 1
    },
    {
      "file": "k8s.hipster.tf",
      "selection": {
        "start": {
          "line": 2,
          "character": 1
        },
        "end": {
          "line": 14,
          "character": 4
        }
      },
      "description": "ğŸ‘‰ Para habilitar o modulo, temos que ir ao ficheiro ./k8s.hipster.tf e descomentar o seguinte modulo:\n\n*module \"hipster\"*\n\nâ›” **nÃ£o descomentar a linha fqdn; serÃ¡ habilitado mais a frente** â›”\n\nğŸ’¡Os microserviÃ§os utilizados nesta demo, encontram-se neste [registry](https://console.cloud.google.com/gcr/images/google-samples/global/microservices-demo) e o respetivo cÃ³digo [neste repositÃ³rio de github](https://github.com/GoogleCloudPlatform/microservices-demo/tree/main).\n\nExecutar terraform init para inicializar o modulo:\n\n>> terraform init\n\nExecutar o plan & apply:\n\n>> terraform plan -out plan.tfplan\n\nExecutar o plan & apply:\n\n>> terraform apply plan.tfplan\n\nâ° ApÃ³s o apply, pode demorar uns minutos a acabar o comando pois o terraform espera que os pods estejam em Running state."
    },
    {
      "file": "k8s.hipster.tf",
      "description": "Podemos verificar que os pods foram corretamente instanciados:\n\n>> kubectl get pods -n hipster-demo\n\nTambÃ©m podemos constatar que o cluster-autoscaler teve que aprovisionar mais nodes para acautelar o demand ğŸ˜ƒğŸš€\n\n>> kubectl get nodes\n\n## 2.5. Testar a nossa aplicaÃ§Ã£o\n\nPara testar e validar a nossa aplicaÃ§Ã£o antes de a colocar em \"produÃ§Ã£o\", podemos tirar partido da capacidade de fazer port-forward.\n\nPara iniciar um port-forward no porto 8080:\n\n>> kubectl port-forward -n hipster-demo service/frontend 8080:80\n\n- ApÃ³s este passo, basta testar a aplicaÃ§Ã£o no port-foward que foi estabelecido no seguinte url: http://localhost:8080\n\n- Se estiverem a usar a Google CloudShell podem clicar em **Preview on Port 8080** no canto superior direito.",
      "line": 15
    },
    {
      "file": "dns.tf",
      "description": "## 3. DNS & HTTPS\n\nConseguimos validar que os workloads estao a funcionar.\n\n- O prÃ³ximo passo serÃ¡ expor a partir dos ingresses e respectivos load-balancers do GKE\n\n- Para isso precisamos de um DNS para HTTP/HTTPS\n\n- Caso queiramos usar HTTPS vamos tambÃ©m precisar de um certificado SSL",
      "line": 11
    },
    {
      "file": "dns.tf",
      "selection": {
        "start": {
          "line": 1,
          "character": 1
        },
        "end": {
          "line": 12,
          "character": 1
        }
      },
      "description": "## 3.1 Criar a zona de DNS\n\nNo ficheiro *./dns.tf* encontra-se a definiÃ§Ã£o do modulo.\n\nğŸ‘‰ Para habilitar o modulo ./dns.tf precisamos de descomentar as seguintes resources:\n\n*module \"dns\"*\n\n*output \"fqdn\"*\n\nExecutar terraform init para inicializar o modulo:\n\n>> terraform init\n\nExecutar o plan:\n\n>> terraform plan -out plan.tfplan\n\nExecutar o apply:\n\n>> terraform apply plan.tfplan\n\nPodemos verificar que a nossa zona de DNS foi corretamente criada atravÃ©s do seguinte comando:\n\n>> gcloud dns managed-zones list --project $(terraform output -raw project_id) | grep $(terraform output -raw my_identifier)"
    },
    {
      "file": "k8s.external-dns.tf",
      "description": "## 3.2 Habilitar o external-dns\n\nO external-dns Ã© a cola entre o Kubernetes e o DNS.\n\nNo ficheiro Ã© necessÃ¡rio passar o **fqdn** devolvido pelo modulo de dns.",
      "line": 1
    },
    {
      "file": "k8s.external-dns.tf",
      "selection": {
        "start": {
          "line": 2,
          "character": 1
        },
        "end": {
          "line": 13,
          "character": 1
        }
      },
      "description": "ğŸ‘‰ Descomentar o modulo **external_dns** no ficheiro **./k8s.external-dns.tf:**\n\n- *module \"external_dns\"*\n- *output \"fqdn\"*\n\nNa diretÃ³ria *./modules/external-dns* encontra-se a implementaÃ§Ã£o do modulo external-dns que permite atualizar os registos DNS automaticamente.\n\nExecutar o init pois estamos a introduzir um novo modulo:\n\n>> terraform init\n\nExecutar o plan:\n\n>> terraform plan -out plan.tfplan\n\nExecutar o apply:\n\n>> terraform apply plan.tfplan"
    },
    {
      "file": "k8s.external-dns.tf",
      "description": "Podemos verificar a criaÃ§Ã£o do external-dns pelo seguinte comando:\n\n>> kubectl get pods -n external-dns\n\nPodemos tambÃ©m investigar os logs emitidos pelo deployment:\n\n>> kubectl logs -n external-dns -l app=external-dns --follow",
      "line": 12
    },
    {
      "file": "k8s.hipster.tf",
      "description": "## 3.3 Criar um ponto de entrada (ingress) para o site\n\n- A criaÃ§Ã£o do ingress serÃ¡ o culminar das Ãºltimas operaÃ§Ãµes que efectuamos (DNS + HTTPS).\n\n- SÃ³ serÃ¡ possivel aceder ao nosso site via internet se o expormos a partir de um ingress;\n\n- A criaÃ§Ã£o do ingress irÃ¡ despoletar a criaÃ§Ã£o de um balanceador com um IP pÃºblico bem como a geraÃ§Ã£o de um certificado gerido pela Google;\n\n- ApÃ³s a atribuiÃ§Ã£o do IP, o external-dns irÃ¡ atualizar o DNS com o respetivo IP;\n\n- Uma vez criado o registo no DNS, o GCE irÃ¡ aprovisionar o certificado automaticamente;\n\nâ° Todo o processo pode levar atÃ© cerca de 10 minutos a acontecer;",
      "line": 1
    },
    {
      "file": "k8s.hipster.tf",
      "selection": {
        "start": {
          "line": 8,
          "character": 1
        },
        "end": {
          "line": 9,
          "character": 27
        }
      },
      "description": "ğŸ‘‰ No ficheiro **./k8s.hipster.tf** iremos descomentar a secÃ§Ã£o 3.3 onde iremos modificar o comportamento do modulo da seguinte forma:\n\nAtribuir o fqdn dado pelo modulo de dns Ã¡ variÃ¡vel fqdn; o fqdn representa o domÃ­nio onde vai ser criado o host declarado pelo ingress.\n\n- **fqdn = module.dns.fqdn**\n\nAtivar a criaÃ§Ã£o dos manifestos de ingress atravÃ©s da variÃ¡vel boleana ingress_enabled.\n\n- **ingress_enabled = true**"
    },
    {
      "file": "k8s.hipster.tf",
      "description": "Executar o plan:\n\n>> terraform plan -out plan.tfplan\n\nExecutar o apply:\n\n>> terraform apply plan.tfplan",
      "line": 7
    },
    {
      "file": "k8s.hipster.tf",
      "description": "Podemos verificar a criaÃ§Ã£o do ingress e a respetiva atribuiÃ§Ã£o de IP a partir dos seguintes comandos:\n\n>> kubectl get ingress -n hipster-demo\n\n>> kubectl describe ingress -n hipster-demo hipster-ingress\n\nTambÃ©m podemos verificar a atuaÃ§Ã£o do external-dns assim que o ingress ganhou um IP:\n\n>> kubectl logs -f -n external-dns -l app=external-dns\n\nOu entÃ£o podemos verificar os registos no Cloud DNS:\n\n>> gcloud dns record-sets list --zone $(terraform output -raw my_identifier)-dns --project $(terraform output -raw project_id)",
      "line": 8
    },
    {
      "file": "k8s.hipster.tf",
      "description": "ğŸš€ Infelizmente, devido ao tempo que a Google demora a gerar os certificados, o site sÃ³ estarÃ¡ disponÃ­vel quando o certificado for gerado e a chain estiver devidamente validada. Este processo leva cerca de 10 minutos â°ğŸ˜¡\n\nPodemos verificar o estado do mesmo usando o seguinte comando:\n\n>> kubectl describe managedcertificates -n hipster-demo hipster",
      "line": 6
    },
    {
      "file": "main.tf",
      "description": "## 4. wrap-up & destroy\n\nPor fim, podemos destruir tudo de uma sÃ³ vez.\n\nâ° Notem que devido Ã  quantidade de recursos envolvidos, a operaÃ§Ã£o de destroy pode demorar entre 10 a 20 minutos.\n\n>> terraform destroy\n\nğŸ”šğŸ ChegÃ¡mos ao fim ğŸğŸ”š",
      "line": 55
    }
  ],
  "ref": "main"
}